{"version":3,"file":"_BUhgkSPo.js","sources":["../../../node_modules/marko/dist/dom.mjs"],"sourcesContent":["// src/common/attr-tag.ts\nvar empty = [], rest = Symbol();\nfunction attrTag(attrs2) {\n  return attrs2[Symbol.iterator] = attrTagIterator, attrs2[rest] = empty, attrs2;\n}\nfunction attrTags(first, attrs2) {\n  return first ? (first[rest] === empty ? first[rest] = [attrs2] : first[rest].push(attrs2), first) : attrTag(attrs2);\n}\nfunction* attrTagIterator() {\n  yield this, yield* this[rest];\n}\n\n// src/common/for.ts\nfunction forIn(obj, cb) {\n  for (let key in obj)\n    cb(key, obj[key]);\n}\nfunction forOf(list, cb) {\n  if (list) {\n    let i = 0;\n    for (let item of list)\n      cb(item, i++);\n  }\n}\nfunction forTo(to, from, step, cb) {\n  let start = from || 0, delta = step || 1;\n  for (let steps = (to - start) / delta, i = 0; i <= steps; i++)\n    cb(start + i * delta);\n}\n\n// src/dom/schedule.ts\nvar port2 = /* @__PURE__ */ (() => {\n  let { port1, port2: port22 } = new MessageChannel();\n  return port1.onmessage = () => {\n    isScheduled = !1, run();\n  }, port22;\n})(), isScheduled;\nfunction schedule() {\n  isScheduled || (isScheduled = !0, queueMicrotask(flushAndWaitFrame));\n}\nfunction flushAndWaitFrame() {\n  run(), requestAnimationFrame(triggerMacroTask);\n}\nfunction triggerMacroTask() {\n  port2.postMessage(0);\n}\n\n// src/common/meta.ts\nvar DEFAULT_RUNTIME_ID = \"M\", DEFAULT_RENDER_ID = \"_\";\n\n// src/dom/scope.ts\nfunction createScope($global) {\n  return {\n    u: 1,\n    $global\n  };\n}\nvar emptyScope = createScope({});\nfunction getEmptyScope(marker) {\n  return emptyScope.a = emptyScope.b = marker, emptyScope;\n}\nfunction destroyScope(scope) {\n  _destroyScope(scope), scope.d?.h?.delete(scope);\n  let closureSignals = scope.x?.c;\n  if (closureSignals)\n    for (let signal of closureSignals)\n      signal.j?.(scope);\n  return scope;\n}\nfunction _destroyScope(scope) {\n  scope.h?.forEach(_destroyScope);\n  let controllers = scope.l;\n  if (controllers)\n    for (let ctrl of controllers.values())\n      ctrl.abort();\n}\nfunction onDestroy(scope) {\n  let parentScope = scope.d;\n  for (; parentScope && !parentScope.h?.has(scope); )\n    (parentScope.h ||= /* @__PURE__ */ new Set()).add(scope), scope = parentScope, parentScope = scope.d;\n}\nfunction removeAndDestroyScope(scope) {\n  destroyScope(scope);\n  let current = scope.a, stop = scope.b.nextSibling;\n  for (; current !== stop; ) {\n    let next = current.nextSibling;\n    current.remove(), current = next;\n  }\n}\nfunction insertBefore(scope, parent, nextSibling) {\n  let current = scope.a, stop = scope.b.nextSibling;\n  for (; current !== stop; ) {\n    let next = current.nextSibling;\n    parent.insertBefore(current, nextSibling), current = next;\n  }\n}\n\n// src/dom/resume.ts\nvar registeredValues = {}, Render = class {\n  m = [];\n  n = {};\n  y = {\n    _: registeredValues\n  };\n  constructor(renders, runtimeId, renderId) {\n    this.z = renders, this.A = runtimeId, this.o = renderId, this.p = renders[renderId], this.q();\n  }\n  w() {\n    this.p.w(), this.q();\n  }\n  q() {\n    let data2 = this.p, serializeContext = this.y, scopeLookup = this.n, visits = data2.v, cleanupOwners = /* @__PURE__ */ new Map();\n    if (visits.length) {\n      let commentPrefixLen = data2.i.length, cleanupMarkers = /* @__PURE__ */ new Map();\n      data2.v = [];\n      let sectionEnd = (visit, scopeId = this.f, curNode = visit) => {\n        let scope = scopeLookup[scopeId] ||= {}, endNode = curNode;\n        for (; (endNode = endNode.previousSibling).nodeType === 8; ) ;\n        scope.b = endNode;\n        let startNode = scope.a ||= endNode, len = cleanupMarkers.size;\n        for (let [markerScopeId, markerNode] of cleanupMarkers) {\n          if (!len--) break;\n          markerScopeId !== scopeId && startNode.compareDocumentPosition(markerNode) & 4 && curNode.compareDocumentPosition(markerNode) & 2 && (cleanupOwners.set(\"\" + markerScopeId, scopeId), cleanupMarkers.delete(markerScopeId));\n        }\n        return cleanupMarkers.set(scopeId, visit), scope;\n      };\n      for (let visit of visits) {\n        let commentText = visit.data, token = commentText[commentPrefixLen], scopeId = parseInt(commentText.slice(commentPrefixLen + 1)), scope = scopeLookup[scopeId] ||= {}, dataIndex = commentText.indexOf(\" \") + 1, data3 = dataIndex ? commentText.slice(dataIndex) : \"\";\n        if (token === \"*\" /* Node */)\n          scope[data3] = visit.previousSibling;\n        else if (token === \"$\" /* Cleanup */)\n          cleanupMarkers.set(scopeId, visit);\n        else if (token === \"[\" /* SectionStart */)\n          this.f && (data3 && sectionEnd(visit), this.m.push(this.f)), this.f = scopeId, scope.a = visit;\n        else if (token === \"]\" /* SectionEnd */) {\n          if (scope[data3] = visit, scopeId < this.f) {\n            let currParent = visit.parentNode, startNode = sectionEnd(visit).a;\n            currParent && currParent !== startNode.parentNode && currParent.prepend(startNode), this.f = this.m.pop();\n          }\n        } else if (token === \"|\" /* SectionSingleNodesEnd */) {\n          scope[parseInt(data3)] = visit;\n          let childScopeIds = JSON.parse(\n            \"[\" + data3.slice(data3.indexOf(\" \") + 1) + \"]\"\n          ), curNode = visit;\n          for (let i = childScopeIds.length - 1; i >= 0; i--)\n            curNode = sectionEnd(visit, childScopeIds[i], curNode).b;\n        }\n      }\n    }\n    let resumes = data2.r;\n    if (resumes) {\n      data2.r = [];\n      let len = resumes.length, i = 0;\n      try {\n        for (isResuming = !0; i < len; ) {\n          let resumeData = resumes[i++];\n          if (typeof resumeData == \"function\") {\n            let scopes = resumeData(serializeContext), { $global } = scopeLookup;\n            $global || (scopeLookup.$global = $global = scopes.$ || {}, $global.runtimeId = this.A, $global.renderId = this.o);\n            for (let scopeId in scopes)\n              if (scopeId !== \"$\") {\n                let scope = scopes[scopeId], prevScope = scopeLookup[scopeId];\n                scope.$global = $global, prevScope !== scope && (scopeLookup[scopeId] = Object.assign(\n                  scope,\n                  prevScope\n                ));\n                let cleanupOwnerId = cleanupOwners.get(scopeId);\n                cleanupOwnerId && (scope.d = scopes[cleanupOwnerId], onDestroy(scope));\n              }\n          } else i === len || typeof resumes[i] != \"string\" ? delete this.z[this.o] : registeredValues[resumes[i++]](\n            scopeLookup[resumeData],\n            scopeLookup[resumeData]\n          );\n        }\n      } finally {\n        isResuming = !1;\n      }\n    }\n  }\n}, isResuming = !1;\nfunction register(id, obj) {\n  return registeredValues[id] = obj, obj;\n}\nfunction registerBoundSignal(id, signal) {\n  return registeredValues[id] = (scope) => (valueOrOp) => signal(scope, valueOrOp), signal;\n}\nfunction getRegisteredWithScope(id, scope) {\n  let val = registeredValues[id];\n  return scope ? val(scope) : val;\n}\nfunction init(runtimeId = DEFAULT_RUNTIME_ID) {\n  let resumeRender = (renderId) => resumeRender[renderId] = renders[renderId] = new Render(renders, runtimeId, renderId), renders;\n  window[runtimeId] ? setRenders(window[runtimeId]) : Object.defineProperty(window, runtimeId, {\n    configurable: !0,\n    set: setRenders\n  });\n  function setRenders(v) {\n    renders = v;\n    for (let renderId in v)\n      resumeRender(renderId);\n    Object.defineProperty(window, runtimeId, {\n      configurable: !0,\n      value: resumeRender\n    });\n  }\n}\nfunction registerSubscriber(id, signal) {\n  return register(id, signal.g), signal;\n}\nfunction nodeRef(id, key) {\n  return register(id, (scope) => () => scope[key]);\n}\n\n// src/dom/signals.ts\nvar MARK = {}, CLEAN = {}, DIRTY = {};\nfunction state(valueAccessor, fn, getIntersection) {\n  let valueSignal = value(valueAccessor, fn, getIntersection), markAccessor = valueAccessor + \"#\" /* Mark */, valueChangeAccessor = valueAccessor + \"@\" /* TagVariableChange */;\n  return (scope, valueOrOp, valueChange) => (rendering ? valueSignal(\n    scope,\n    valueOrOp === MARK || valueOrOp === CLEAN || valueOrOp === DIRTY || (scope[valueChangeAccessor] = valueChange) || scope[markAccessor] === void 0 ? valueOrOp : CLEAN\n  ) : scope[valueChangeAccessor] ? scope[valueChangeAccessor](valueOrOp) : queueSource(scope, valueSignal, valueOrOp), valueOrOp);\n}\nfunction value(valueAccessor, fn, getIntersection) {\n  let markAccessor = valueAccessor + \"#\" /* Mark */, intersection2 = getIntersection && ((scope, op) => (intersection2 = getIntersection())(scope, op));\n  return (scope, valueOrOp) => {\n    if (valueOrOp === MARK)\n      (scope[markAccessor] = (scope[markAccessor] ?? 0) + 1) === 1 && intersection2?.(scope, MARK);\n    else if (valueOrOp !== DIRTY) {\n      let existing = scope[markAccessor] !== void 0;\n      (scope[markAccessor] ||= 1) === 1 && (valueOrOp === CLEAN || existing && scope[valueAccessor] === valueOrOp ? intersection2?.(scope, CLEAN) : (scope[valueAccessor] = valueOrOp, fn && fn(scope, valueOrOp), intersection2?.(scope, DIRTY))), scope[markAccessor]--;\n    }\n  };\n}\nvar accessorId = 0;\nfunction intersection(count, fn, getIntersection) {\n  let dirtyAccessor = \"?\" /* Dynamic */ + accessorId++, markAccessor = dirtyAccessor + \"#\" /* Mark */, intersection2 = getIntersection && ((scope, op) => (intersection2 = getIntersection())(scope, op));\n  return (scope, op) => {\n    op === MARK ? (scope[markAccessor] = (scope[markAccessor] ?? 0) + 1) === 1 && intersection2?.(scope, MARK) : scope[markAccessor] === void 0 ? (scope[markAccessor] = count - 1, scope[dirtyAccessor] = !0) : --scope[markAccessor] === 0 ? op === DIRTY || scope[dirtyAccessor] ? (scope[dirtyAccessor] = !1, fn(scope, 0), intersection2?.(scope, DIRTY)) : intersection2?.(scope, CLEAN) : scope[dirtyAccessor] ||= op === DIRTY;\n  };\n}\nvar defaultGetOwnerScope = (scope) => scope._;\nfunction closure(ownerValueAccessor, fn, getOwnerScope = defaultGetOwnerScope, getIntersection) {\n  let dirtyAccessor = \"?\" /* Dynamic */ + accessorId++, markAccessor = dirtyAccessor + 1, getOwnerValueAccessor = typeof ownerValueAccessor == \"function\" ? ownerValueAccessor : () => ownerValueAccessor, intersection2 = getIntersection && ((scope, op) => (intersection2 = getIntersection())(scope, op));\n  return (scope, op) => {\n    if (op === MARK)\n      (scope[markAccessor] = (scope[markAccessor] ?? 0) + 1) === 1 && intersection2?.(scope, MARK);\n    else {\n      let ownerScope, ownerValueAccessor2;\n      if (scope[markAccessor] === void 0) {\n        ownerScope = getOwnerScope(scope), ownerValueAccessor2 = getOwnerValueAccessor(scope);\n        let ownerMark = ownerScope[ownerValueAccessor2 + \"#\" /* Mark */], ownerHasRun = ownerMark === void 0 ? !ownerScope.u : ownerMark === 0;\n        scope[markAccessor] = ownerHasRun ? 1 : 2, op = DIRTY;\n      }\n      --scope[markAccessor] === 0 ? op === DIRTY || scope[dirtyAccessor] ? (scope[dirtyAccessor] = !1, ownerScope ||= getOwnerScope(scope), ownerValueAccessor2 ||= getOwnerValueAccessor(scope), fn && fn(scope, ownerScope[ownerValueAccessor2]), intersection2?.(scope, DIRTY)) : intersection2?.(scope, CLEAN) : scope[dirtyAccessor] ||= op === DIRTY;\n    }\n  };\n}\nfunction dynamicClosure(ownerValueAccessor, fn, getOwnerScope = defaultGetOwnerScope, getIntersection) {\n  let getOwnerValueAccessor = typeof ownerValueAccessor == \"function\" ? ownerValueAccessor : () => ownerValueAccessor, signalFn = closure(\n    getOwnerValueAccessor,\n    fn,\n    getOwnerScope,\n    getIntersection\n  ), subscribeFns = /* @__PURE__ */ new WeakMap();\n  return signalFn.g = (scope) => {\n    let subscribeFn = (value2) => signalFn(scope, value2), ownerScope = getOwnerScope(scope), providerSubscriptionsAccessor = getOwnerValueAccessor(scope) + \"*\" /* Subscribers */;\n    subscribeFns.set(scope, subscribeFn), (ownerScope[providerSubscriptionsAccessor] ||= /* @__PURE__ */ new Set()).add(subscribeFn);\n  }, signalFn.j = (scope) => {\n    let ownerScope = getOwnerScope(scope), providerSubscriptionsAccessor = getOwnerValueAccessor(scope) + \"*\" /* Subscribers */;\n    ownerScope[providerSubscriptionsAccessor]?.delete(subscribeFns.get(scope)), subscribeFns.delete(scope);\n  }, signalFn;\n}\nfunction childClosures(closureSignals, childAccessor) {\n  let signal = (scope, op) => {\n    let childScope = scope[childAccessor];\n    for (let closureSignal of closureSignals)\n      closureSignal(childScope, op);\n  };\n  return signal.g = (scope) => {\n    let childScope = scope[childAccessor];\n    for (let closureSignal of closureSignals)\n      closureSignal.g?.(childScope);\n  }, signal.j = (scope) => {\n    let childScope = scope[childAccessor];\n    for (let closureSignal of closureSignals)\n      closureSignal.j?.(childScope);\n  }, signal;\n}\nfunction dynamicSubscribers(valueAccessor) {\n  let subscribersAccessor = valueAccessor + \"*\" /* Subscribers */;\n  return (scope, op) => {\n    let subscribers = scope[subscribersAccessor];\n    if (subscribers)\n      for (let subscriber of subscribers)\n        subscriber(op);\n  };\n}\nfunction setTagVar(scope, childAccessor, tagVarSignal2) {\n  scope[childAccessor][\"/\" /* TagVariable */] = (valueOrOp) => tagVarSignal2(scope, valueOrOp);\n}\nvar tagVarSignal = (scope, valueOrOp) => scope[\"/\" /* TagVariable */]?.(valueOrOp);\nfunction setTagVarChange(scope, changeHandler) {\n  scope[\"@\" /* TagVariableChange */] = changeHandler;\n}\nvar tagVarSignalChange = (scope, value2) => scope[\"@\" /* TagVariableChange */]?.(value2), renderBodyClosures = (renderBody, childScope, op) => {\n  let signals = renderBody?.c;\n  if (signals)\n    for (let signal of signals)\n      signal(childScope, op);\n};\nvar tagIdsByGlobal = /* @__PURE__ */ new WeakMap();\nfunction nextTagId({ $global }) {\n  let id = tagIdsByGlobal.get($global) || 0;\n  return tagIdsByGlobal.set($global, id + 1), \"c\" + $global.runtimeId + $global.renderId + id.toString(36);\n}\nfunction inChild(childAccessor, signal) {\n  return (scope, valueOrOp) => {\n    signal(scope[childAccessor], valueOrOp);\n  };\n}\nfunction intersections(signals) {\n  return (scope, op) => {\n    for (let signal of signals)\n      signal(scope, op);\n  };\n}\nfunction effect(id, fn) {\n  return register(id, fn), (scope) => {\n    queueEffect(scope, fn);\n  };\n}\n\n// src/dom/queue.ts\nvar pendingSignals = [], pendingEffects = [], rendering = !1;\nfunction queueSource(scope, signal, value2) {\n  return schedule(), rendering = !0, signal(scope, MARK), rendering = !1, pendingSignals.push(scope, signal, value2), value2;\n}\nfunction queueEffect(scope, fn) {\n  pendingEffects.push(scope, fn);\n}\nfunction run() {\n  let signals = pendingSignals, effects = pendingEffects;\n  try {\n    rendering = !0, pendingSignals = [], runSignals(signals);\n  } finally {\n    rendering = !1;\n  }\n  pendingEffects = [], runEffects(effects);\n}\nfunction prepareEffects(fn) {\n  let prevSignals = pendingSignals, prevEffects = pendingEffects, preparedEffects = pendingEffects = [], preparedSignals = pendingSignals = [];\n  try {\n    rendering = !0, fn(), pendingSignals = prevSignals, runSignals(preparedSignals);\n  } finally {\n    rendering = !1, pendingSignals = prevSignals, pendingEffects = prevEffects;\n  }\n  return preparedEffects;\n}\nfunction runEffects(effects = pendingEffects) {\n  for (let i = 0; i < effects.length; i += 2 /* Total */) {\n    let scope = effects[i], fn = effects[i + 1];\n    fn(scope, scope);\n  }\n}\nfunction runSignals(signals) {\n  for (let i = 0; i < signals.length; i += 3 /* Total */) {\n    let scope = signals[i + 0 /* Scope */], signal = signals[i + 1 /* Signal */], value2 = signals[i + 2 /* Value */];\n    signal(scope, value2);\n  }\n}\n\n// src/dom/abort-signal.ts\nfunction resetAbortSignal(scope, id) {\n  let controllers = scope.l;\n  if (controllers) {\n    let ctrl = controllers.get(id);\n    ctrl && (queueEffect(null, () => ctrl.abort()), controllers.delete(id));\n  }\n}\nfunction getAbortSignal(scope, id) {\n  let controllers = scope.l ||= /* @__PURE__ */ new Map(), controller = controllers.get(id);\n  return controller || (onDestroy(scope), controllers.set(id, controller = new AbortController())), controller.signal;\n}\n\n// src/common/compat-meta.ts\nvar prefix = \"$C_\", RENDERER_REGISTER_ID = prefix + \"r\", SET_SCOPE_REGISTER_ID = prefix + \"s\";\n\n// src/common/helpers.ts\nfunction classValue(value2) {\n  return toDelimitedString(value2, \" \", stringifyClassObject);\n}\nfunction stringifyClassObject(name, value2) {\n  return value2 ? name : \"\";\n}\nfunction styleValue(value2) {\n  return toDelimitedString(value2, \";\", stringifyStyleObject);\n}\nvar NON_DIMENSIONAL = /^(--|ta|or|li|z)|n-c|i(do|nk|m|t)|w$|we/;\nfunction stringifyStyleObject(name, value2) {\n  return value2 || value2 === 0 ? `${name}:${typeof value2 == \"number\" && value2 && !NON_DIMENSIONAL.test(name) ? value2 + \"px\" : value2}` : \"\";\n}\nfunction toDelimitedString(val, delimiter, stringify) {\n  switch (typeof val) {\n    case \"string\":\n      return val;\n    case \"object\":\n      if (val !== null) {\n        let result = \"\", curDelimiter = \"\";\n        if (Array.isArray(val))\n          for (let v of val) {\n            let part = toDelimitedString(v, delimiter, stringify);\n            part !== \"\" && (result += curDelimiter + part, curDelimiter = delimiter);\n          }\n        else\n          for (let name in val) {\n            let v = val[name], part = stringify(name, v);\n            part !== \"\" && (result += curDelimiter + part, curDelimiter = delimiter);\n          }\n        return result;\n      }\n  }\n  return \"\";\n}\nfunction isEventHandler(name) {\n  return /^on[A-Z-]/.test(name);\n}\nfunction getEventHandlerName(name) {\n  return name[2] === \"-\" ? name.slice(3) : name.slice(2).toLowerCase();\n}\nfunction normalizeDynamicRenderer(value2) {\n  if (value2) return value2.renderBody || value2.default || value2;\n}\n\n// src/dom/reconcile.ts\nvar WRONG_POS = 2147483647;\nfunction reconcile(parent, oldScopes, newScopes, afterReference) {\n  let oldStart = 0, newStart = 0, oldEnd = oldScopes.length - 1, newEnd = newScopes.length - 1, oldStartScope = oldScopes[oldStart], newStartScope = newScopes[newStart], oldEndScope = oldScopes[oldEnd], newEndScope = newScopes[newEnd], i, j, k, nextSibling, oldScope, newScope;\n  outer: {\n    for (; oldStartScope === newStartScope; ) {\n      if (++oldStart, ++newStart, oldStart > oldEnd || newStart > newEnd)\n        break outer;\n      oldStartScope = oldScopes[oldStart], newStartScope = newScopes[newStart];\n    }\n    for (; oldEndScope === newEndScope; ) {\n      if (--oldEnd, --newEnd, oldStart > oldEnd || newStart > newEnd)\n        break outer;\n      oldEndScope = oldScopes[oldEnd], newEndScope = newScopes[newEnd];\n    }\n  }\n  if (oldStart > oldEnd) {\n    if (newStart <= newEnd) {\n      k = newEnd + 1, nextSibling = k < newScopes.length ? newScopes[k].a : afterReference;\n      do\n        insertBefore(newScopes[newStart++], parent, nextSibling);\n      while (newStart <= newEnd);\n    }\n  } else if (newStart > newEnd)\n    do\n      removeAndDestroyScope(oldScopes[oldStart++]);\n    while (oldStart <= oldEnd);\n  else {\n    let oldLength = oldEnd - oldStart + 1, newLength = newEnd - newStart + 1, aNullable = oldScopes, sources = new Array(newLength);\n    for (i = 0; i < newLength; ++i)\n      sources[i] = -1;\n    let pos = 0, synced = 0, keyIndex = /* @__PURE__ */ new Map();\n    for (j = newStart; j <= newEnd; ++j)\n      keyIndex.set(newScopes[j], j);\n    for (i = oldStart; i <= oldEnd && synced < newLength; ++i)\n      oldScope = oldScopes[i], j = keyIndex.get(oldScope), j !== void 0 && (pos = pos > j ? WRONG_POS : j, ++synced, newScope = newScopes[j], sources[j - newStart] = i, aNullable[i] = null);\n    if (oldLength === oldScopes.length && synced === 0) {\n      for (; newStart < newLength; ++newStart)\n        insertBefore(newScopes[newStart], parent, afterReference);\n      for (; oldStart < oldLength; ++oldStart)\n        removeAndDestroyScope(oldScopes[oldStart]);\n    } else {\n      for (i = oldLength - synced; i > 0; )\n        oldScope = aNullable[oldStart++], oldScope !== null && (removeAndDestroyScope(oldScope), i--);\n      if (pos === WRONG_POS) {\n        let seq = longestIncreasingSubsequence(sources);\n        for (j = seq.length - 1, k = newScopes.length, i = newLength - 1; i >= 0; --i)\n          sources[i] === -1 ? (pos = i + newStart, newScope = newScopes[pos++], nextSibling = pos < k ? newScopes[pos].a : afterReference, insertBefore(newScope, parent, nextSibling)) : j < 0 || i !== seq[j] ? (pos = i + newStart, newScope = newScopes[pos++], nextSibling = pos < k ? newScopes[pos].a : afterReference, insertBefore(newScope, parent, nextSibling)) : --j;\n      } else if (synced !== newLength)\n        for (k = newScopes.length, i = newLength - 1; i >= 0; --i)\n          sources[i] === -1 && (pos = i + newStart, newScope = newScopes[pos++], nextSibling = pos < k ? newScopes[pos].a : afterReference, insertBefore(newScope, parent, nextSibling));\n    }\n  }\n}\nfunction longestIncreasingSubsequence(a) {\n  let p = a.slice(), result = [];\n  result.push(0);\n  let u, v;\n  for (let i = 0, il = a.length; i < il; ++i) {\n    if (a[i] === -1)\n      continue;\n    let j = result[result.length - 1];\n    if (a[j] < a[i]) {\n      p[i] = j, result.push(i);\n      continue;\n    }\n    for (u = 0, v = result.length - 1; u < v; ) {\n      let c = (u + v) / 2 | 0;\n      a[result[c]] < a[i] ? u = c + 1 : v = c;\n    }\n    a[i] < a[result[u]] && (u > 0 && (p[i] = result[u - 1]), result[u] = i);\n  }\n  for (u = result.length, v = result[u - 1]; u-- > 0; )\n    result[u] = v, v = p[v];\n  return result;\n}\n\n// src/dom/event.ts\nvar elementHandlersByEvent = /* @__PURE__ */ new Map(), defaultDelegator = createDelegator();\nfunction on(element, type, handler) {\n  let handlersByElement = elementHandlersByEvent.get(type);\n  handlersByElement || elementHandlersByEvent.set(type, handlersByElement = /* @__PURE__ */ new WeakMap()), handlersByElement.has(element) || defaultDelegator(element, type, handleDelegated), handlersByElement.set(element, handler || void 0);\n}\nfunction createDelegator() {\n  let delegatedEventsByRoot = /* @__PURE__ */ new WeakMap();\n  return function(node, type, handler) {\n    let root = node.getRootNode(), delegatedEvents = delegatedEventsByRoot.get(root);\n    delegatedEvents || delegatedEventsByRoot.set(root, delegatedEvents = /* @__PURE__ */ new Set()), delegatedEvents.has(type) || (delegatedEvents.add(type), root.addEventListener(type, handler, !0));\n  };\n}\nfunction handleDelegated(ev) {\n  let target = ev.target;\n  if (target) {\n    let handlersByElement = elementHandlersByEvent.get(ev.type);\n    if (handlersByElement.get(target)?.(ev, target), ev.bubbles)\n      for (; (target = target.parentElement) && !ev.cancelBubble; )\n        handlersByElement.get(target)?.(ev, target);\n  }\n}\n\n// src/dom/resolve-cursor-position.ts\nfunction resolveCursorPosition(updatedValue, initialValue, initialPosition, inputType2) {\n  if (initialPosition !== initialValue.length || // short regex to match input types that delete backwards\n  /kw/.test(inputType2)) {\n    let before = initialValue.slice(0, initialPosition), after = initialValue.slice(initialPosition);\n    if (updatedValue.startsWith(before))\n      return initialPosition;\n    if (updatedValue.endsWith(after))\n      return updatedValue.length - after.length;\n    {\n      let relevantChars = stripSpacesAndPunctuation(before).length, pos = 0, relevantIndex = 0;\n      for (; relevantIndex < relevantChars; )\n        stripSpacesAndPunctuation(updatedValue[pos]) && relevantIndex++, pos++;\n      return pos;\n    }\n  }\n  return -1;\n}\nfunction stripSpacesAndPunctuation(str) {\n  return str.replace(/[^\\p{L}\\p{N}]/gu, \"\");\n}\n\n// src/dom/controllable.ts\nfunction controllable_input_checked(scope, nodeAccessor, checked, checkedChange) {\n  setCheckboxValue(\n    scope,\n    nodeAccessor,\n    0 /* InputChecked */,\n    normalizeBoolProp(checked),\n    checkedChange\n  );\n}\nfunction controllable_input_checked_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor];\n  syncControllable(el, \"input\", hasCheckboxChanged, () => {\n    let checkedChange = scope[nodeAccessor + \";\" /* ControlledHandler */];\n    checkedChange && (scope[nodeAccessor + \"=\" /* ControlledType */] = 6 /* Pending */, checkedChange(el.checked), run(), scope[nodeAccessor + \"=\" /* ControlledType */] === 6 /* Pending */ && (el.checked = !el.checked));\n  });\n}\nfunction controllable_input_checkedValue(scope, nodeAccessor, checkedValue, checkedValueChange, value2) {\n  scope[nodeAccessor + \":\" /* ControlledValue */] = checkedValue, attr(scope[nodeAccessor], \"value\", value2), setCheckboxValue(\n    scope,\n    nodeAccessor,\n    1 /* InputCheckedValue */,\n    Array.isArray(checkedValue) ? checkedValue.includes(value2) : checkedValue === value2,\n    checkedValueChange\n  );\n}\nfunction controllable_input_checkedValue_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor];\n  syncControllable(el, \"input\", hasCheckboxChanged, () => {\n    let checkedValueChange = scope[nodeAccessor + \";\" /* ControlledHandler */];\n    if (checkedValueChange) {\n      let oldValue = scope[nodeAccessor + \":\" /* ControlledValue */];\n      scope[nodeAccessor + \"=\" /* ControlledType */] = 6 /* Pending */, checkedValueChange(\n        Array.isArray(oldValue) ? updateList(oldValue, el.value, el.checked) : el.checked ? el.value : void 0\n      ), run(), scope[nodeAccessor + \"=\" /* ControlledType */] === 6 /* Pending */ && (el.checked = !el.checked);\n    }\n  });\n}\nfunction controllable_input_value(scope, nodeAccessor, value2, valueChange) {\n  let el = scope[nodeAccessor], normalizedValue = normalizeStrProp(value2);\n  scope[nodeAccessor + \";\" /* ControlledHandler */] = valueChange, valueChange ? (scope[nodeAccessor + \"=\" /* ControlledType */] = 0 /* InputChecked */, scope[nodeAccessor + \":\" /* ControlledValue */] = value2, el.isConnected ? setValueAndUpdateSelection(el, normalizedValue) : el.defaultValue = normalizedValue) : (scope[nodeAccessor + \"=\" /* ControlledType */] = 5 /* None */, el.defaultValue = normalizedValue);\n}\nfunction controllable_input_value_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor];\n  isResuming && (scope[nodeAccessor + \":\" /* ControlledValue */] = el.defaultValue), syncControllable(el, \"input\", hasValueChanged, (ev) => {\n    let valueChange = scope[nodeAccessor + \";\" /* ControlledHandler */];\n    valueChange && (scope[nodeAccessor + \"=\" /* ControlledType */] = 6 /* Pending */, ev && (inputType = ev.inputType), valueChange(el.value), run(), scope[nodeAccessor + \"=\" /* ControlledType */] === 6 /* Pending */ && setValueAndUpdateSelection(\n      el,\n      scope[nodeAccessor + \":\" /* ControlledValue */]\n    ), inputType = \"\");\n  });\n}\nfunction controllable_select_value(scope, nodeAccessor, value2, valueChange) {\n  scope[nodeAccessor + \";\" /* ControlledHandler */] = valueChange, valueChange ? (scope[nodeAccessor + \"=\" /* ControlledType */] = 3 /* SelectValue */, scope[nodeAccessor + \":\" /* ControlledValue */] = value2) : scope[nodeAccessor + \"=\" /* ControlledType */] = 5 /* None */, setSelectOptions(\n    scope[nodeAccessor],\n    value2,\n    valueChange\n  );\n}\nfunction controllable_select_value_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor];\n  syncControllable(el, \"input\", hasSelectChanged, () => {\n    let valueChange = scope[nodeAccessor + \";\" /* ControlledHandler */];\n    valueChange && (scope[nodeAccessor + \"=\" /* ControlledType */] = 6 /* Pending */, valueChange(\n      Array.isArray(scope[nodeAccessor + \":\" /* ControlledValue */]) ? Array.from(el.selectedOptions, toValueProp) : el.value\n    ), run(), scope[nodeAccessor + \"=\" /* ControlledType */] === 6 /* Pending */ && setSelectOptions(\n      el,\n      scope[nodeAccessor + \":\" /* ControlledValue */],\n      valueChange\n    ));\n  });\n}\nfunction setSelectOptions(el, value2, valueChange) {\n  if (Array.isArray(value2))\n    for (let opt of el.options) {\n      let selected = value2.includes(opt.value);\n      valueChange ? opt.selected = selected : opt.defaultSelected = selected;\n    }\n  else {\n    let normalizedValue = normalizeStrProp(value2);\n    if (valueChange)\n      el.value = normalizedValue;\n    else\n      for (let opt of el.options)\n        opt.defaultSelected = opt.value === normalizedValue;\n  }\n}\nfunction controllable_detailsOrDialog_open(scope, nodeAccessor, open, openChange) {\n  scope[nodeAccessor + \";\" /* ControlledHandler */] = openChange, openChange ? scope[nodeAccessor + \"=\" /* ControlledType */] = 4 /* DetailsOrDialogOpen */ : scope[nodeAccessor + \"=\" /* ControlledType */] = 5 /* None */, scope[nodeAccessor].open = normalizeBoolProp(open);\n}\nfunction controllable_detailsOrDialog_open_effect(scope, nodeAccessor) {\n  let el = scope[nodeAccessor], hasChanged = () => el.open !== scope[nodeAccessor + \":\" /* ControlledValue */];\n  syncControllable(\n    el,\n    el.tagName === \"DIALOG\" ? \"close\" : \"toggle\",\n    hasChanged,\n    () => {\n      let openChange = scope[nodeAccessor + \";\" /* ControlledHandler */];\n      openChange && hasChanged() && (scope[nodeAccessor + \"=\" /* ControlledType */] = 6 /* Pending */, openChange(el.open), run(), scope[nodeAccessor + \"=\" /* ControlledType */] === 6 /* Pending */ && (el.open = !el.open));\n    }\n  );\n}\nvar inputType = \"\";\nfunction setValueAndUpdateSelection(el, value2) {\n  let initialValue = el.value;\n  if (initialValue !== value2)\n    if (el.getRootNode().activeElement === el) {\n      let initialPosition = el.selectionStart;\n      el.value = value2;\n      let updatedPosition = resolveCursorPosition(\n        el.value,\n        initialValue,\n        initialPosition,\n        inputType\n      );\n      ~updatedPosition && el.setSelectionRange(updatedPosition, updatedPosition);\n    } else\n      el.value = value2;\n}\nfunction setCheckboxValue(scope, nodeAccessor, type, checked, checkedChange) {\n  scope[nodeAccessor + \";\" /* ControlledHandler */] = checkedChange, checkedChange ? (scope[nodeAccessor + \"=\" /* ControlledType */] = type, scope[nodeAccessor].checked = checked) : (scope[nodeAccessor + \"=\" /* ControlledType */] = 5 /* None */, scope[nodeAccessor].defaultChecked = checked);\n}\nvar delegateFormControl = createDelegator(), formChangeHandlers = /* @__PURE__ */ new WeakMap();\nfunction syncControllable(el, event, hasChanged, onChange) {\n  formChangeHandlers.set(el, onChange), delegateFormControl(el, event, onFormChange), el.form && delegateFormControl(el.form, \"reset\", onFormReset), isResuming && hasChanged(el) && queueMicrotask(onChange);\n}\nfunction onFormChange(ev) {\n  formChangeHandlers.get(ev.target)?.(ev);\n}\nfunction onFormReset(ev) {\n  let handlers = [];\n  for (let el of ev.target.elements) {\n    let handler = formChangeHandlers.get(el);\n    handler && hasFormElementChanged(el) && handlers.push(handler);\n  }\n  requestAnimationFrame(() => {\n    if (!ev.defaultPrevented)\n      for (let change of handlers)\n        change();\n  });\n}\nfunction hasValueChanged(el) {\n  return el.value !== el.defaultValue;\n}\nfunction hasCheckboxChanged(el) {\n  return el.checked !== el.defaultChecked;\n}\nfunction hasSelectChanged(el) {\n  for (let opt of el.options)\n    if (opt.selected !== opt.defaultSelected)\n      return !0;\n}\nfunction hasFormElementChanged(el) {\n  return el.options ? hasSelectChanged(el) : hasValueChanged(el) || hasCheckboxChanged(el);\n}\nfunction normalizeStrProp(value2) {\n  return normalizeAttrValue(value2) || \"\";\n}\nfunction normalizeBoolProp(value2) {\n  return value2 != null && value2 !== !1;\n}\nfunction updateList(arr, val, push) {\n  let index = arr.indexOf(val);\n  return (push ? !~index && [...arr, val] : ~index && arr.slice(0, index).concat(arr.slice(index + 1))) || arr;\n}\nfunction toValueProp(it) {\n  return it.value;\n}\n\n// src/dom/parse-html.ts\nvar fallback = document.createTextNode(\"\"), parser = /* @__PURE__ */ new Range();\nfunction parseHTML(html2) {\n  return parser.createContextualFragment(html2);\n}\nfunction parseHTMLOrSingleNode(html2) {\n  let content = parseHTML(html2);\n  return content.firstChild ? content.firstChild === content.lastChild && // If the firstChild is a comment it's possible its\n  // a single replaced node, in which case the walker can't replace\n  // the node itself.\n  content.firstChild.nodeType !== 8 ? content.firstChild : content : fallback;\n}\n\n// src/dom/dom.ts\nfunction attr(element, name, value2) {\n  setAttribute(element, name, normalizeAttrValue(value2));\n}\nfunction setAttribute(element, name, value2) {\n  element.getAttribute(name) != value2 && (value2 === void 0 ? element.removeAttribute(name) : element.setAttribute(name, value2));\n}\nfunction classAttr(element, value2) {\n  setAttribute(element, \"class\", classValue(value2) || void 0);\n}\nfunction styleAttr(element, value2) {\n  setAttribute(element, \"style\", styleValue(value2) || void 0);\n}\nfunction data(node, value2) {\n  let normalizedValue = normalizeString(value2);\n  node.data !== normalizedValue && (node.data = normalizedValue);\n}\nfunction textContent(node, value2) {\n  let normalizedValue = normalizeString(value2);\n  node.textContent !== normalizedValue && (node.textContent = normalizedValue);\n}\nfunction attrs(scope, nodeAccessor, nextAttrs) {\n  let el = scope[nodeAccessor];\n  for (let { name } of el.attributes)\n    nextAttrs && (name in nextAttrs || hasAttrAlias(el, name, nextAttrs)) || el.removeAttribute(name);\n  attrsInternal(scope, nodeAccessor, nextAttrs);\n}\nfunction hasAttrAlias(element, attr2, nextAttrs) {\n  return attr2 === \"checked\" && element.tagName === \"INPUT\" && \"checkedValue\" in nextAttrs;\n}\nfunction partialAttrs(scope, nodeAccessor, nextAttrs, skip) {\n  let el = scope[nodeAccessor], partial = {};\n  for (let { name } of el.attributes)\n    !skip[name] && !(nextAttrs && name in nextAttrs) && el.removeAttribute(name);\n  for (let key in nextAttrs)\n    skip[key] || (partial[key] = nextAttrs[key]);\n  attrsInternal(scope, nodeAccessor, partial);\n}\nfunction attrsInternal(scope, nodeAccessor, nextAttrs) {\n  let el = scope[nodeAccessor], events, skip;\n  switch (el.tagName) {\n    case \"INPUT\":\n      if (\"checked\" in nextAttrs || \"checkedChange\" in nextAttrs)\n        controllable_input_checked(\n          scope,\n          nodeAccessor,\n          nextAttrs.checked,\n          nextAttrs.checkedChange\n        );\n      else if (\"checkedValue\" in nextAttrs || \"checkedValueChange\" in nextAttrs)\n        controllable_input_checkedValue(\n          scope,\n          nodeAccessor,\n          nextAttrs.checkedValue,\n          nextAttrs.checkedValueChange,\n          nextAttrs.value\n        );\n      else if (\"value\" in nextAttrs || \"valueChange\" in nextAttrs)\n        controllable_input_value(\n          scope,\n          nodeAccessor,\n          nextAttrs.value,\n          nextAttrs.valueChange\n        );\n      else\n        break;\n      skip = /^(?:value|checked(?:Value)?)(?:Change)?$/;\n      break;\n    case \"SELECT\":\n      (\"value\" in nextAttrs || \"valueChange\" in nextAttrs) && (controllable_select_value(\n        scope,\n        nodeAccessor,\n        nextAttrs.value,\n        nextAttrs.valueChange\n      ), skip = /^value(?:Change)?$/);\n      break;\n    case \"TEXTAREA\":\n      (\"value\" in nextAttrs || \"valueChange\" in nextAttrs) && (controllable_input_value(\n        scope,\n        nodeAccessor,\n        nextAttrs.value,\n        nextAttrs.valueChange\n      ), skip = /^value(?:Change)?$/);\n      break;\n    case \"DETAILS\":\n    case \"DIALOG\":\n      (\"open\" in nextAttrs || \"openChange\" in nextAttrs) && (controllable_detailsOrDialog_open(\n        scope,\n        nodeAccessor,\n        nextAttrs.open,\n        nextAttrs.openChange\n      ), skip = /^open(?:Change)?$/);\n      break;\n  }\n  for (let name in nextAttrs) {\n    let value2 = nextAttrs[name];\n    switch (name) {\n      case \"class\":\n        classAttr(el, value2);\n        break;\n      case \"style\":\n        styleAttr(el, value2);\n        break;\n      case \"renderBody\":\n        break;\n      default:\n        isEventHandler(name) ? (events ||= scope[nodeAccessor + \"~\" /* EventAttributes */] = {})[getEventHandlerName(name)] = value2 : skip?.test(name) || attr(el, name, value2);\n    }\n  }\n}\nfunction attrsEvents(scope, nodeAccessor) {\n  let el = scope[nodeAccessor], events = scope[nodeAccessor + \"~\" /* EventAttributes */];\n  switch (scope[nodeAccessor + \"=\" /* ControlledType */]) {\n    case 0 /* InputChecked */:\n      controllable_input_checked_effect(scope, nodeAccessor);\n      break;\n    case 1 /* InputCheckedValue */:\n      controllable_input_checkedValue_effect(scope, nodeAccessor);\n      break;\n    case 2 /* InputValue */:\n      controllable_input_value_effect(scope, nodeAccessor);\n      break;\n    case 3 /* SelectValue */:\n      controllable_select_value_effect(scope, nodeAccessor);\n      break;\n    case 4 /* DetailsOrDialogOpen */:\n      controllable_detailsOrDialog_open_effect(scope, nodeAccessor);\n      break;\n  }\n  for (let name in events)\n    on(el, name, events[name]);\n}\nfunction html(scope, value2, index) {\n  let firstChild = scope[index], lastChild = scope[index + \"-\"] || firstChild, parentNode = firstChild.parentNode, afterReference = lastChild.nextSibling, newContent = parseHTML(value2 || value2 === 0 ? value2 + \"\" : \"<!>\");\n  scope[index] = newContent.firstChild, scope[index + \"-\" /* DynamicPlaceholderLastChild */] = newContent.lastChild, parentNode.insertBefore(newContent, firstChild);\n  let current = firstChild;\n  for (; current !== afterReference; ) {\n    let next = current.nextSibling;\n    current.remove(), current = next;\n  }\n}\nfunction props(scope, nodeIndex, index) {\n  let nextProps = scope[index], prevProps = scope[index + \"-\"], node = scope[nodeIndex];\n  if (prevProps)\n    for (let name in prevProps)\n      name in nextProps || (node[name] = void 0);\n  for (let name in nextProps)\n    node[name] = nextProps[name];\n  scope[index + \"-\"] = nextProps;\n}\nfunction normalizeAttrValue(value2) {\n  if (value2 || value2 === 0)\n    return value2 === !0 ? \"\" : value2 + \"\";\n}\nfunction normalizeString(value2) {\n  return value2 || value2 === 0 ? value2 + \"\" : \"\\u200D\";\n}\nfunction lifecycle(scope, index, thisObj) {\n  let instance = scope[index];\n  instance ? (Object.assign(instance, thisObj), instance.onUpdate?.()) : (scope[index] = thisObj, thisObj.onMount?.(), getAbortSignal(\n    scope,\n    \"-\" /* LifecycleAbortController */ + index\n  ).onabort = () => thisObj.onDestroy?.());\n}\n\n// src/dom/walker.ts\nvar walker = /* @__PURE__ */ document.createTreeWalker(document);\nfunction trimWalkString(walkString) {\n  let end = walkString.length;\n  for (; walkString.charCodeAt(--end) > 47 /* BeginChild */; ) ;\n  return walkString.slice(0, end + 1);\n}\nfunction walk(startNode, walkCodes, scope) {\n  walker.currentNode = startNode, walkInternal(walkCodes, scope, scope, 0), walker.currentNode = document.documentElement;\n}\nfunction walkInternal(walkCodes, scope, cleanupOwnerScope, currentWalkIndex) {\n  let value2, storedMultiplier = 0, currentMultiplier = 0, currentScopeIndex = 0;\n  for (cleanupOwnerScope !== scope && (scope.d = cleanupOwnerScope); value2 = walkCodes.charCodeAt(currentWalkIndex++); )\n    if (currentMultiplier = storedMultiplier, storedMultiplier = 0, value2 >= 117 /* Multiplier */)\n      storedMultiplier = currentMultiplier * 10 /* Multiplier */ + value2 - 117 /* Multiplier */;\n    else if (value2 >= 107 /* Out */) {\n      for (value2 = 10 /* Out */ * currentMultiplier + value2 - 107 /* Out */; value2--; )\n        walker.parentNode();\n      walker.nextSibling();\n    } else if (value2 >= 97 /* Over */)\n      for (value2 = 10 /* Over */ * currentMultiplier + value2 - 97 /* Over */; value2--; )\n        walker.nextSibling();\n    else if (value2 >= 67 /* Next */)\n      for (value2 = 20 /* Next */ * currentMultiplier + value2 - 67 /* Next */; value2--; )\n        walker.nextNode();\n    else if (value2 === 47 /* BeginChild */)\n      currentWalkIndex = walkInternal(\n        walkCodes,\n        scope[currentScopeIndex++] = createScope(scope.$global),\n        cleanupOwnerScope,\n        currentWalkIndex\n      );\n    else {\n      if (value2 === 38 /* EndChild */)\n        return currentWalkIndex;\n      if (value2 === 32 /* Get */)\n        scope[currentScopeIndex++] = walker.currentNode;\n      else {\n        let newNode = scope[currentScopeIndex++] = document.createTextNode(\"\"), current = walker.currentNode;\n        current.parentNode.replaceChild(newNode, current), walker.currentNode = newNode;\n      }\n    }\n  return currentWalkIndex;\n}\n\n// src/dom/renderer.ts\nfunction createScopeWithRenderer(renderer, $global, ownerScope) {\n  let newScope = createScope($global);\n  if (newScope._ = newScope.d = renderer.B || ownerScope, newScope.x = renderer, initRenderer(renderer, newScope), renderer.c)\n    for (let signal of renderer.c)\n      signal.g?.(newScope);\n  return newScope;\n}\nfunction createScopeWithTagNameOrRenderer(tagNameOrRenderer, $global, ownerScope) {\n  if (typeof tagNameOrRenderer != \"string\")\n    return createScopeWithRenderer(tagNameOrRenderer, $global, ownerScope);\n  let newScope = createScope($global);\n  return newScope._ = newScope.d = ownerScope, newScope[0] = newScope.a = newScope.b = document.createElement(tagNameOrRenderer), newScope;\n}\nfunction initRenderer(renderer, scope) {\n  let dom = renderer.k();\n  return walk(\n    dom.nodeType === 11 /* DocumentFragment */ ? dom.firstChild : dom,\n    renderer.C,\n    scope\n  ), scope.a = dom.nodeType === 11 /* DocumentFragment */ ? dom.firstChild : dom, scope.b = dom.nodeType === 11 /* DocumentFragment */ ? dom.lastChild : dom, renderer.s && renderer.s(scope), dom;\n}\nfunction dynamicTagAttrs(nodeAccessor, getRenderBody, inputIsArgs) {\n  return (scope, attrsOrOp) => {\n    let renderer = scope[nodeAccessor + \"(\" /* ConditionalRenderer */];\n    if (!renderer || attrsOrOp === DIRTY)\n      return;\n    let childScope = scope[nodeAccessor + \"!\" /* ConditionalScope */];\n    if (attrsOrOp === MARK || attrsOrOp === CLEAN)\n      return renderer.e?.(childScope, attrsOrOp);\n    let renderBody = getRenderBody?.(scope);\n    if (typeof renderer == \"string\")\n      setConditionalRendererOnlyChild(childScope, 0, renderBody), attrs(childScope, 0, attrsOrOp());\n    else if (renderer.e) {\n      let attributes = attrsOrOp();\n      renderer.e(\n        childScope,\n        inputIsArgs ? attributes : [\n          renderBody ? {\n            ...attributes,\n            renderBody\n          } : attributes\n        ]\n      );\n    }\n  };\n}\nfunction createRendererWithOwner(template, rawWalks, setup, getClosureSignals, getArgs) {\n  let args, closureSignals, id = {}, walks = rawWalks ? /* @__PURE__ */ trimWalkString(rawWalks) : \" \";\n  return (owner) => ({\n    t: id,\n    D: template,\n    C: walks,\n    s: setup,\n    k: _clone,\n    B: owner,\n    E: void 0,\n    get e() {\n      return args ||= getArgs?.();\n    },\n    get c() {\n      return closureSignals ||= new Set(getClosureSignals?.());\n    }\n  });\n}\nfunction createRenderer(template, walks, setup, getClosureSignals, getArgs) {\n  return createRendererWithOwner(\n    template,\n    walks,\n    setup,\n    getClosureSignals,\n    getArgs\n  )();\n}\nfunction _clone() {\n  return (this.E ||= parseHTMLOrSingleNode(\n    this.D\n  )).cloneNode(!0);\n}\n\n// src/dom/control-flow.ts\nfunction patchConditionals(fn) {\n  conditional = fn(conditional), conditionalOnlyChild = fn(conditionalOnlyChild);\n}\nvar conditional = function(nodeAccessor, fn, getIntersection) {\n  let rendererAccessor = nodeAccessor + \"(\" /* ConditionalRenderer */, childScopeAccessor = nodeAccessor + \"!\" /* ConditionalScope */, intersection2 = getIntersection && ((scope, op) => (intersection2 = getIntersection())(scope, op));\n  return (scope, newRendererOrOp) => {\n    if (newRendererOrOp === DIRTY) return;\n    let currentRenderer = scope[rendererAccessor], op = newRendererOrOp;\n    if (newRendererOrOp !== MARK && newRendererOrOp !== CLEAN) {\n      let normalizedRenderer = normalizeDynamicRenderer(newRendererOrOp);\n      isDifferentRenderer(normalizedRenderer, currentRenderer) ? (currentRenderer = scope[rendererAccessor] = normalizedRenderer, setConditionalRenderer(scope, nodeAccessor, normalizedRenderer), fn && fn(scope), op = DIRTY) : op = CLEAN;\n    }\n    intersection2?.(scope, op), renderBodyClosures(currentRenderer, scope[childScopeAccessor], op);\n  };\n};\nfunction inConditionalScope(signal, nodeAccessor) {\n  let scopeAccessor = nodeAccessor + \"!\" /* ConditionalScope */, rendererAccessor = nodeAccessor + \"(\" /* ConditionalRenderer */;\n  return (scope, op) => {\n    let conditionalScope = scope[scopeAccessor];\n    if (conditionalScope) {\n      let conditionalRenderer = scope[rendererAccessor];\n      (!conditionalRenderer?.c || conditionalRenderer.c.has(signal)) && signal(conditionalScope, op);\n    }\n  };\n}\nfunction setConditionalRenderer(scope, nodeAccessor, newRenderer) {\n  let newScope, prevScope = scope[nodeAccessor + \"!\" /* ConditionalScope */];\n  newRenderer ? (newScope = scope[nodeAccessor + \"!\" /* ConditionalScope */] = createScopeWithTagNameOrRenderer(\n    newRenderer,\n    scope.$global,\n    scope\n  ), prevScope = prevScope || getEmptyScope(scope[nodeAccessor])) : (newScope = getEmptyScope(scope[nodeAccessor]), scope[nodeAccessor + \"!\" /* ConditionalScope */] = void 0), insertBefore(\n    newScope,\n    prevScope.a.parentNode,\n    prevScope.a\n  ), removeAndDestroyScope(prevScope);\n}\nvar conditionalOnlyChild = function(nodeAccessor, fn, getIntersection) {\n  let rendererAccessor = nodeAccessor + \"(\" /* ConditionalRenderer */, childScopeAccessor = nodeAccessor + \"!\" /* ConditionalScope */, intersection2 = getIntersection && ((scope, op) => (intersection2 = getIntersection())(scope, op));\n  return (scope, newRendererOrOp) => {\n    if (newRendererOrOp === DIRTY) return;\n    let currentRenderer = scope[rendererAccessor], op = newRendererOrOp;\n    if (newRendererOrOp !== MARK && newRendererOrOp !== CLEAN) {\n      let normalizedRenderer = normalizeDynamicRenderer(newRendererOrOp);\n      isDifferentRenderer(normalizedRenderer, currentRenderer) ? (currentRenderer = scope[rendererAccessor] = normalizedRenderer, setConditionalRendererOnlyChild(\n        scope,\n        nodeAccessor,\n        normalizedRenderer\n      ), fn && fn(scope), op = DIRTY) : op = CLEAN;\n    }\n    intersection2?.(scope, op), renderBodyClosures(currentRenderer, scope[childScopeAccessor], op);\n  };\n};\nfunction setConditionalRendererOnlyChild(scope, nodeAccessor, newRenderer) {\n  let prevScope = scope[nodeAccessor + \"!\" /* ConditionalScope */], referenceNode = scope[nodeAccessor];\n  if (referenceNode.textContent = \"\", newRenderer) {\n    let newScope = scope[nodeAccessor + \"!\" /* ConditionalScope */] = createScopeWithTagNameOrRenderer(newRenderer, scope.$global, scope);\n    insertBefore(newScope, referenceNode, null);\n  }\n  prevScope && destroyScope(prevScope);\n}\nvar emptyMarkerMap = /* @__PURE__ */ new Map([[Symbol(), getEmptyScope(void 0)]]), emptyMarkerArray = [\n  /* @__PURE__ */ getEmptyScope(void 0)\n], emptyMap = /* @__PURE__ */ new Map(), emptyArray = [];\nfunction loopOf(nodeAccessor, renderer) {\n  return loop(\n    nodeAccessor,\n    renderer,\n    ([all, by = bySecondArg], cb) => {\n      typeof by == \"string\" ? forOf(\n        all,\n        (item, i) => cb(item[by], [item, i])\n      ) : forOf(all, (item, i) => cb(by(item, i), [item, i]));\n    }\n  );\n}\nfunction loopIn(nodeAccessor, renderer) {\n  return loop(\n    nodeAccessor,\n    renderer,\n    ([obj, by = byFirstArg], cb) => forIn(obj, (key, value2) => cb(by(key, value2), [key, value2]))\n  );\n}\nfunction loopTo(nodeAccessor, renderer) {\n  return loop(\n    nodeAccessor,\n    renderer,\n    ([to, from, step, by = byFirstArg], cb) => forTo(to, from, step, (v) => cb(by(v), [v]))\n  );\n}\nfunction loop(nodeAccessor, renderer, forEach) {\n  let loopScopeAccessor = nodeAccessor + \"!\" /* LoopScopeArray */, closureSignals = renderer.c, params = renderer.e;\n  return (scope, valueOrOp) => {\n    if (valueOrOp === DIRTY) return;\n    if (valueOrOp === MARK || valueOrOp === CLEAN) {\n      let loopScopes = scope[loopScopeAccessor] ?? scope[nodeAccessor + \"(\" /* LoopScopeMap */]?.values() ?? [];\n      if (loopScopes !== emptyMarkerArray)\n        for (let childScope of loopScopes) {\n          params?.(childScope, valueOrOp);\n          for (let signal of closureSignals)\n            signal(childScope, valueOrOp);\n        }\n      return;\n    }\n    let referenceNode = scope[nodeAccessor], referenceIsMarker = referenceNode.nodeType === 8 || referenceNode.nodeType === 3, oldMap = scope[nodeAccessor + \"(\" /* LoopScopeMap */] || (referenceIsMarker ? emptyMarkerMap : emptyMap), oldArray = scope[nodeAccessor + \"!\" /* LoopScopeArray */] || Array.from(oldMap.values()), newMap, newArray, afterReference, parentNode, needsReconciliation = !0;\n    if (forEach(valueOrOp, (key, args) => {\n      let childScope = oldMap.get(key), closureOp = CLEAN;\n      if (childScope || (childScope = createScopeWithRenderer(renderer, scope.$global, scope), closureOp = DIRTY), params && params(childScope, args), closureSignals)\n        for (let signal of closureSignals)\n          signal(childScope, closureOp);\n      newMap ? (newMap.set(key, childScope), newArray.push(childScope)) : (newMap = /* @__PURE__ */ new Map([[key, childScope]]), newArray = [childScope]);\n    }), newMap || (referenceIsMarker ? (newMap = emptyMarkerMap, newArray = emptyMarkerArray, getEmptyScope(referenceNode)) : (oldArray.forEach(destroyScope), referenceNode.textContent = \"\", newMap = emptyMap, newArray = emptyArray, needsReconciliation = !1)), needsReconciliation) {\n      if (referenceIsMarker) {\n        oldMap === emptyMarkerMap && getEmptyScope(referenceNode);\n        let oldLastChild = oldArray[oldArray.length - 1];\n        afterReference = oldLastChild.b.nextSibling, parentNode = oldLastChild.a.parentNode;\n      } else\n        afterReference = null, parentNode = referenceNode;\n      reconcile(parentNode, oldArray, newArray, afterReference);\n    }\n    scope[nodeAccessor + \"(\" /* LoopScopeMap */] = newMap, scope[nodeAccessor + \"!\" /* LoopScopeArray */] = newArray;\n  };\n}\nfunction inLoopScope(signal, loopNodeAccessor) {\n  let loopScopeAccessor = loopNodeAccessor + \"!\" /* LoopScopeArray */;\n  return (scope, op) => {\n    let loopScopes = scope[loopScopeAccessor] ?? scope[loopNodeAccessor + \"(\" /* LoopScopeMap */]?.values() ?? [];\n    if (loopScopes !== emptyMarkerArray)\n      for (let scope2 of loopScopes)\n        signal(scope2, op);\n  };\n}\nfunction bySecondArg(_item, index) {\n  return index;\n}\nfunction byFirstArg(name) {\n  return name;\n}\nfunction isDifferentRenderer(a, b) {\n  return a !== b && (a?.t || 0) !== b?.t;\n}\n\n// src/dom/compat.ts\nvar classIdToScope = /* @__PURE__ */ new Map(), compat = {\n  patchConditionals,\n  queueEffect,\n  init() {\n    register(SET_SCOPE_REGISTER_ID, (scope) => {\n      classIdToScope.set(scope.m5c, scope);\n    });\n  },\n  registerRenderer(fn) {\n    register(RENDERER_REGISTER_ID, fn);\n  },\n  isOp(value2) {\n    return value2 === MARK || value2 === CLEAN || value2 === DIRTY;\n  },\n  isRenderer(renderer) {\n    return renderer.k !== void 0;\n  },\n  getStartNode(scope) {\n    return scope.a;\n  },\n  setScopeNodes(scope, startNode, endNode) {\n    scope.a = startNode, scope.b = endNode;\n  },\n  runComponentEffects() {\n    runEffects(this.effects);\n  },\n  resolveRegistered(value2, {\n    runtimeId,\n    componentIdPrefix\n  }) {\n    return Array.isArray(value2) && typeof value2[0] == \"string\" ? getRegisteredWithScope(\n      value2[0],\n      value2.length === 2 && window[runtimeId]?.[componentIdPrefix === \"s\" ? \"_\" : componentIdPrefix]?.n[value2[1]]\n    ) : value2;\n  },\n  createRenderer(setup, clone, args) {\n    let renderer = createRenderer(\n      \"\",\n      void 0,\n      setup,\n      void 0,\n      args && (() => args)\n    );\n    return renderer.k = clone, renderer;\n  },\n  render(out, component, renderer, input) {\n    let scope = component.scope;\n    scope || (scope = classIdToScope.get(component.id), scope && (component.scope = scope, classIdToScope.delete(component.id)));\n    let args = renderer.e || noop, existing = !1;\n    if (component.effects = prepareEffects(() => {\n      if (scope)\n        args(scope, MARK), existing = !0;\n      else {\n        scope = component.scope = createScopeWithRenderer(renderer, out.global);\n        let closures = renderer.c;\n        if (closures)\n          for (let signal of closures)\n            signal(component.scope, CLEAN);\n      }\n      args(scope, input);\n    }), !existing)\n      return scope.a === scope.b ? scope.a : scope.a.parentNode;\n  }\n};\nfunction noop() {\n}\n\n// src/dom/template.ts\nvar createTemplate = (templateId, ...rendererArgs) => {\n  let renderer = createRenderer(...rendererArgs);\n  return renderer.mount = mount, renderer._ = renderer, register(templateId, renderer);\n};\nfunction mount(input = {}, reference, position) {\n  let scope, dom, { $global } = input;\n  $global ? ({ $global, ...input } = input, $global = {\n    runtimeId: DEFAULT_RUNTIME_ID,\n    renderId: DEFAULT_RENDER_ID,\n    ...$global\n  }) : $global = {\n    runtimeId: DEFAULT_RUNTIME_ID,\n    renderId: DEFAULT_RENDER_ID\n  };\n  let args = this.e, effects = prepareEffects(() => {\n    scope = createScope($global), dom = initRenderer(this, scope), args && args(scope, [input]);\n  });\n  switch (position) {\n    case \"afterbegin\":\n      reference.insertBefore(dom, reference.firstChild);\n      break;\n    case \"afterend\":\n      reference.parentElement.insertBefore(dom, reference.nextSibling);\n      break;\n    case \"beforebegin\":\n      reference.parentElement.insertBefore(dom, reference);\n      break;\n    default:\n      reference.appendChild(dom);\n      break;\n  }\n  return runEffects(effects), {\n    update: (newInput) => {\n      args && runEffects(\n        prepareEffects(() => {\n          args(scope, MARK), args(scope, [newInput]);\n        })\n      );\n    },\n    destroy: () => {\n      removeAndDestroyScope(scope);\n    }\n  };\n}\nexport {\n  attr,\n  attrTag,\n  attrTags,\n  attrs,\n  attrsEvents,\n  childClosures,\n  classAttr,\n  closure,\n  compat,\n  conditional,\n  conditionalOnlyChild,\n  controllable_detailsOrDialog_open,\n  controllable_detailsOrDialog_open_effect,\n  controllable_input_checked,\n  controllable_input_checkedValue,\n  controllable_input_checkedValue_effect,\n  controllable_input_checked_effect,\n  controllable_input_value,\n  controllable_input_value_effect,\n  controllable_select_value,\n  controllable_select_value_effect,\n  controllable_input_value as controllable_textarea_value,\n  controllable_input_value_effect as controllable_textarea_value_effect,\n  createRenderer,\n  createRendererWithOwner,\n  createScope,\n  createTemplate,\n  data,\n  dynamicClosure,\n  dynamicSubscribers,\n  dynamicTagAttrs,\n  effect,\n  forIn,\n  forOf,\n  forTo,\n  getAbortSignal,\n  html,\n  inChild,\n  inConditionalScope,\n  inLoopScope,\n  init,\n  intersection,\n  intersections,\n  lifecycle,\n  loopIn,\n  loopOf,\n  loopTo,\n  nextTagId,\n  nodeRef,\n  on,\n  partialAttrs,\n  props,\n  register,\n  registerBoundSignal,\n  registerSubscriber,\n  resetAbortSignal,\n  run,\n  setTagVar,\n  setTagVarChange,\n  state,\n  styleAttr,\n  tagVarSignal,\n  tagVarSignalChange,\n  textContent,\n  value\n};\n"],"names":["forOf","list","cb","i","item","forTo","to","from","step","start","delta","steps","port2","port1","port22","isScheduled","run","schedule","flushAndWaitFrame","triggerMacroTask","DEFAULT_RUNTIME_ID","createScope","$global","emptyScope","getEmptyScope","marker","destroyScope","scope","_destroyScope","closureSignals","signal","controllers","ctrl","onDestroy","parentScope","removeAndDestroyScope","current","stop","next","insertBefore","parent","nextSibling","registeredValues","Render","renders","runtimeId","renderId","data2","serializeContext","scopeLookup","visits","cleanupOwners","commentPrefixLen","cleanupMarkers","sectionEnd","visit","scopeId","curNode","endNode","startNode","len","markerScopeId","markerNode","commentText","token","dataIndex","data3","currParent","childScopeIds","resumes","isResuming","resumeData","scopes","prevScope","cleanupOwnerId","register","id","obj","registerBoundSignal","valueOrOp","init","resumeRender","setRenders","v","registerSubscriber","MARK","CLEAN","DIRTY","state","valueAccessor","fn","getIntersection","valueSignal","value","markAccessor","valueChangeAccessor","valueChange","rendering","queueSource","intersection2","op","existing","accessorId","intersection","count","dirtyAccessor","defaultGetOwnerScope","closure","ownerValueAccessor","getOwnerScope","getOwnerValueAccessor","ownerScope","ownerValueAccessor2","ownerMark","ownerHasRun","dynamicClosure","signalFn","subscribeFns","subscribeFn","value2","providerSubscriptionsAccessor","dynamicSubscribers","subscribersAccessor","subscribers","subscriber","setTagVar","childAccessor","tagVarSignal2","tagVarSignal","setTagVarChange","changeHandler","tagVarSignalChange","renderBodyClosures","renderBody","childScope","signals","inChild","intersections","effect","queueEffect","pendingSignals","pendingEffects","effects","runSignals","runEffects","resetAbortSignal","getAbortSignal","controller","classValue","toDelimitedString","stringifyClassObject","name","styleValue","stringifyStyleObject","NON_DIMENSIONAL","val","delimiter","stringify","result","curDelimiter","part","normalizeDynamicRenderer","WRONG_POS","reconcile","oldScopes","newScopes","afterReference","oldStart","newStart","oldEnd","newEnd","oldStartScope","newStartScope","oldEndScope","newEndScope","j","k","oldScope","newScope","outer","oldLength","newLength","aNullable","sources","pos","synced","keyIndex","seq","longestIncreasingSubsequence","a","p","u","il","c","elementHandlersByEvent","defaultDelegator","createDelegator","on","element","type","handler","handlersByElement","handleDelegated","delegatedEventsByRoot","node","root","delegatedEvents","ev","target","fallback","parser","parseHTML","html2","parseHTMLOrSingleNode","content","attr","setAttribute","normalizeAttrValue","classAttr","styleAttr","data","normalizedValue","normalizeString","walker","trimWalkString","walkString","end","walk","walkCodes","walkInternal","cleanupOwnerScope","currentWalkIndex","storedMultiplier","currentMultiplier","currentScopeIndex","newNode","createScopeWithRenderer","renderer","initRenderer","createScopeWithTagNameOrRenderer","tagNameOrRenderer","dom","createRendererWithOwner","template","rawWalks","setup","getClosureSignals","getArgs","args","walks","owner","_clone","createRenderer","conditional","nodeAccessor","rendererAccessor","childScopeAccessor","newRendererOrOp","currentRenderer","normalizedRenderer","isDifferentRenderer","setConditionalRenderer","inConditionalScope","scopeAccessor","conditionalScope","conditionalRenderer","newRenderer","emptyMarkerMap","emptyMarkerArray","emptyMap","emptyArray","loopOf","loop","all","by","bySecondArg","loopTo","byFirstArg","forEach","loopScopeAccessor","params","loopScopes","referenceNode","referenceIsMarker","oldMap","oldArray","newMap","newArray","parentNode","needsReconciliation","key","closureOp","oldLastChild","_item","index","b"],"mappings":"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","x_google_ignoreList":[0]}