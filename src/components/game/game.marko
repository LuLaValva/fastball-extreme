export enum TileType {
  Empty,
  Tile,
  Spikes,
  Start,
  Goal,
  DirectLeft,
  DirectRight,
  Spring,
}
export interface Input {
  tiles: TileType[][];
}
static declare global {
  namespace Marko {
    namespace CSS {
      export interface Properties {
        "--x": number;
        "--y": number;
      }
    }
  }
}

const/startPos=((): [number, number] => {
  for (let i = 0; i < input.tiles.length; i++) {
    for (let j = 0; j < input.tiles[i].length; j++) {
      if (input.tiles[i][j] === TileType.Start) {
        return [j, i];
      }
    }
  }
  return [0, 0];
})()

let/ballPos=[...startPos]
client function now() {
  return +document.timeline.currentTime!;
}

let/lastFrame=null as number | null
let/jumping=false

script
  --
  document.addEventListener(
    "keydown",
    (e) => {
      if (
        e.target instanceof Element &&
        e.target.matches("button, [role='button'], input, select, textarea")
      ) {
        return;
      }
      if (e.key === " ") {
        if (lastFrame === null) {
          lastFrame = now();
        } else {
          jumping = true;
        }
      }
    },
    {
      signal: $signal,
    },
  );
  document.addEventListener(
    "keyup",
    (e) => {
      if (e.key === " ") {
        jumping = false;
      }
    },
    {
      signal: $signal,
    },
  );
  document.addEventListener(
    "pointerdown",
    (e) => {
      if (
        e.target instanceof Element &&
        e.target.matches("button, [role='button'], input, select, textarea")
      ) {
        return;
      }
      if (lastFrame === null) {
        lastFrame = now();
      } else {
        jumping = true;
      }
    },
    {
      signal: $signal,
    },
  );
  document.addEventListener(
    "pointerup",
    (e) => {
      jumping = false;
    },
    {
      signal: $signal,
    },
  );
  --

local-let/deaths=0 key=`level-${$global.params.id}-deaths`
local-let/victory=false key=`level-${$global.params.id}-victory`
static const GRAVITY = 0.015;
static const BASE_SPEED = 0.1;

let/velX=BASE_SPEED
let/velY=0

let/dummy=true
static const FRAME_RATE = 1000 / 60;
script
  --
  if (lastFrame !== null) {
    dummy = !dummy;
    const currentTime = now();
    let gameTime: number | null = lastFrame;
    if (gameTime && currentTime - gameTime > FRAME_RATE) {
      gameTime += FRAME_RATE;
      let nextPos = [ballPos[0] + velX, ballPos[1] + velY];

      // ground collision
      if (
        input.tiles[Math.floor(nextPos[1] + 1)]?.[
          Math.floor(nextPos[0] + 0.5)
        ] === TileType.Tile
      ) {
        velY = jumping ? GRAVITY * -16 : 0;
        nextPos[1] = Math.floor(nextPos[1]);
      } else {
        velY += GRAVITY;
      }

      // death
      if (
        nextPos[1] > input.tiles.length + 10 ||
        input.tiles[Math.floor(nextPos[1] + 0.5)]?.[
          Math.floor(nextPos[0] + 1)
        ] === TileType.Tile ||
        input.tiles[Math.floor(nextPos[1] + 0.8)]?.[
          Math.floor(nextPos[0] + 0.8)
        ] === TileType.Tile ||
        input.tiles[Math.floor(nextPos[1])]?.[Math.floor(nextPos[0] + 0.5)] ===
          TileType.Tile ||
        input.tiles[Math.floor(nextPos[1] + 0.2)]?.[
          Math.floor(nextPos[0] + 0.8)
        ] === TileType.Tile ||
        input.tiles[Math.floor(nextPos[1] + 0.5)]?.[
          Math.floor(nextPos[0] + 0.5)
        ] === TileType.Spikes
      ) {
        nextPos = [...startPos];
        gameTime = null;
        velX = BASE_SPEED;
        velY = 0;
        deaths++;
      }
      switch (
        input.tiles[Math.floor(nextPos[1] + 0.5)]?.[
          Math.floor(nextPos[0] + 0.5)
        ]
      ) {
        case TileType.Goal:
          gameTime = null;
          victory = true;
          window.location.href = "/level/" + (+($global.params.id ?? 0) + 1);
          break;
        case TileType.DirectLeft:
          velX = -BASE_SPEED;
          break;
        case TileType.DirectRight:
          velX = BASE_SPEED;
          break;
        case TileType.Spring:
          velY = GRAVITY * -26;
          break;
      }
      ballPos = nextPos;
    }
    lastFrame = gameTime;
  }
  --

div.game
  div.view style={ "--x": ballPos[0], "--y": ballPos[1] }
    div [
      class={
        ball: true,
        moving: lastFrame !== null,
      }
      style={
        "animation-duration": 0.15 / Math.abs(velX) + "s",
        "animation-direction": velX < 0 ? "reverse" : undefined,
      }
    ]

    for|{ x, y, type }| of=input.tiles.flatMap((row, y) =>
      row.flatMap((type, x) =>
        type === TileType.Empty || type === TileType.Start
          ? []
          : [{ x, y, type }],
      ),
    )
      if=type === TileType.Tile
        div.tile style={ "--x": x, "--y": y }
      else if=type === TileType.Spikes
        div.spikes style={ "--x": x, "--y": y }
      else if=type === TileType.Goal
        div.goal style={ "--x": x, "--y": y }
      else if=type === TileType.DirectLeft
        div.left-sign style={ "--x": x, "--y": y }
      else if=type === TileType.DirectRight
        div.right-sign style={ "--x": x, "--y": y }
      else if=type === TileType.Spring
        div.spring style={ "--x": x, "--y": y }
      html-comment

style
  --
  .game {
    position: fixed;
    inset: 0;
    z-index: -1;
  }

  .game .view {
    position: absolute;
    left: calc(50vw - 2.5vmax + var(--x) * -5vmax);
    top: calc(50vh - 2.5vmax + var(--y) * -5vmax);
  }

  .game .view div {
    position: absolute;
    width: 5vmax;
    height: 5vmax;
    left: calc(var(--x) * 5vmax);
    top: calc(var(--y) * 5vmax);
    background-size: cover;
  }

  .tile {
    background-image: url("assets/tile.png");
    z-index: -1;
  }

  .goal {
    background-image: url("assets/flag.png");
  }

  .left-sign {
    background-image: url("assets/left-sign.png");
  }

  .right-sign {
    background-image: url("assets/right-sign.png");
  }

  .spring {
    background-image: url("assets/spring.png");
  }

  .ball {
    background-image: url("assets/ball.png");
    z-index: 1;

    &.moving {
      animation: spin linear infinite;
    }
  }

  .spikes {
    background-image: url("assets/spikes.png");
  }

  @keyframes spin {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }
  --
